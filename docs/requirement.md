跨平台内核事件采集方案需求（最终整理版）
1. 项目定位

目标：构建一个高性能、跨平台的内核级事件采集系统
支持平台：Linux和Windows
架构原则：平台无关核心（70-75%代码） + 平台相关适配层（25-30%代码）；接口与协议需向前兼容
实现方式：内核驱动/内核扩展

2. 核心功能需求
2.1 事件采集范围

文件事件：open/close/read/write/create/delete/rename/chmod等
进程事件：fork/exec/exit/setuid/kill/ptrace等
网络事件：connect/bind/listen/accept/send/recv等

2.2 不同平台采集策略

Linux：

主要数据源：LSM（Linux Security Module）框架
辅助数据源：少量Kprobe（仅fork等LSM未覆盖事件）
优势：稳定API、原生阻断支持、低性能开销


Windows：

MiniFilter（文件系统过滤）
进程/线程创建回调
WFP（Windows Filtering Platform）
注册表/对象回调



3. 事件处理机制

3.1 过滤和控制

采集到的事件将经过初步的过滤，存在内置的白名单
初步过滤需要支持简单的过滤条件，包括：进程名称、进程路径前缀匹配、文件后缀匹配、文件路径匹配、文件操作进程名称、网络端口、网络IP段、网络协议
Bypass控制也会在这一步完成，可按事件类型动态开关
如果没有用户态程序订阅某一类事件，在这一步就会返回，不会继续分发
支持运行时更新bypass等控制配置

3.2 分发机制

事件经过初步过滤后，会交由不同的内核业务模块进一步加工
每个内核模块都可以对事件进行二次加工
支持多个内核业务模块同时订阅同一事件，分发时将按顺序逐个分发
内核业务模块会决定处理完的数据是否需要上抛，如需上抛将调用对应同步或异步上抛的接口
一个事件所有上抛结束后需汇总处置结果

3.3 上抛机制

上抛事件注册：
支持用户态向内核态订阅事件，订阅时需要说明是需要同步的上抛还是异步上抛
如果需要是同步上抛，注册时需要说明超时时间，允许不设置则为默认超时时间
同一个事件支持被多个用户态进程订阅
上抛时每个事件按照注册的同步异步要求逐个顺序执行上抛

同步上抛：

需要等待应用层返回阻断决策，才能继续向后分发
通过EventFD/Event通知用户态
每种事件内置最大超时时间，按照事件的频率暂定一个，超时自动放行
Linux考虑通过ioctl实现，Windows考虑通过DeviceIoControl


异步上抛：

不等待响应，直接写入事件缓冲区
通过EventFD/Event通知用户态
如果通过共享内存实现，所有事件需要确认应用层处理完成后，才能清理共享内存中对应事件

上抛信息结构：

不同事件的信息长度可能不一样，通常不会大于8K，设计要考虑如何减少空间浪费


4. 核心技术方案
4.1 数据缓冲区设计
关键特性：

单份数据存储，多进程共享读取（零拷贝），所有进程读取完才允许被GC
进度信息内嵌在事件中，无需独立进度表
用户态通过原子操作直接确认，无需系统调用
GC直接检查ack_bitmap判断回收
内核和用户态的事件字段可能存在版本差异，数据结构和缓冲区设计要能做到兼容
本次不需要支持热升级（本系统升级过程中不能中断采集能力），但未来可能需要热升级，本次设计上要有双副本或双缓冲的预留


4.2 通信机制

数据传输：共享内存（Linux mmap / Windows MapView）
事件通知：EventFD / Windows Event
控制接口：ioctl / DeviceIoControl
心跳机制：定期上报存活状态

5. 可靠性设计
5.1 垃圾回收策略

基于ack_bitmap的智能回收
超时强制回收
两阶段回收：标记作废 → RCU宽限期 → 真正回收

5.2 异常处理

慢读进程：检测并区分慢读vs卡死
进程崩溃：自动清理资源，不影响其他进程
缓冲区满：分级处理（软限制70%/硬限制90%/紧急95%）
兜底机制：强制跳过或创建快照

5.3 并发安全

内核层和应用层数据交互要考虑多生产者多消费者
RCU保护读路径
原子操作避免锁竞争
Per-CPU缓冲优化

6. 平台抽象设计

抽离平台无关的接口
封装平台有关的接口
工程使用CMAKE统一组织管理

7. 性能指标

低延迟：微秒级事件采集和分发
高吞吐：支持10万+事件/秒
低开销：CPU占用<5%，内存占用<64MB
零拷贝：共享内存避免数据复制

8. 部署要求
Linux

内核版本：4.x以上（LSM stacking支持）
编译选项：CONFIG_SECURITY=y
加载方式：编译进内核或LSM模块

Windows

驱动签名要求
过滤驱动注册
WDF/WDM框架

9. 设计原则

避免过度设计，一套机制解决问题
最小化条件编译，通过函数指针隔离平台差异
用户态承担管理责任，内核提供机制
性能优先，但保证可靠性
模块划分职责边界要清晰
模块间接口和数据结构要定义好，接口也要定义好，但不需要实现
总体架构图要充分体现分层设计
每个可能大于200行代码的机制都要绘图说明
注意每个子模块都要有6. 流程设计这一章节

10. 注意事项
图表：
所有的图表要使用mermaid语法编写
对于含中文的内容要加双引号
避免或减少使用特殊符号
图表头部需有```mermaid，尾部需有```