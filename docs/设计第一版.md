# 跨平台内核事件采集系统设计文档

## 1. 项目概述

### 1.1 项目背景与定位
- **目标定位**：构建高性能、跨平台的内核级事件采集系统
- **支持平台**：Linux（4.x+）、Windows（Win7+）
- **实现方式**：内核驱动/内核扩展
- **架构原则**：
  - 平台无关核心（70-75%代码）
  - 平台相关适配层（25-30%代码）
  - 接口与协议向前兼容

### 1.2 性能指标要求
| 指标类型 | 目标值 | 说明 |
|---------|--------|------|
| 延迟 | < 10μs | 事件采集到分发的延迟 |
| 吞吐量 | > 100,000 events/s | 峰值处理能力 |
| CPU占用 | < 5% | 正常负载下的CPU使用率 |
| 内存占用 | < 64MB | 内核态总内存占用 |
| 数据传输 | 零拷贝 | 共享内存避免数据复制 |

## 2. 系统架构设计

### 2.1 总体架构图

```mermaid
graph TB
    subgraph "用户态"
        UA["用户态应用1"]
        UB["用户态应用2"]
        UC["用户态应用N"]
        UM["管理进程"]
    end
    
    subgraph "通信层"
        SM["共享内存缓冲区"]
        EV["事件通知机制"]
        CT["控制接口"]
    end
    
    subgraph "内核态"
        subgraph "平台无关层"
            ER["事件路由器"]
            EF["事件过滤器"]
            ED["事件分发器"]
            BM["缓冲区管理器"]
            GC["垃圾回收器"]
        end
        
        subgraph "业务模块层"
            M1["业务模块1"]
            M2["业务模块2"]
            M3["业务模块N"]
        end
        
        subgraph "平台适配层"
            PA["平台抽象接口"]
            subgraph "Linux适配"
                LSM["LSM Hook"]
                KP["Kprobe"]
            end
            subgraph "Windows适配"
                MF["MiniFilter"]
                PC["进程回调"]
                WFP["WFP"]
            end
        end
    end
    
    UA --> SM
    UB --> SM
    UC --> SM
    UM --> CT
    
    SM <--> BM
    EV <--> ED
    CT <--> ER
    
    ER --> EF
    EF --> ED
    ED --> M1
    ED --> M2
    ED --> M3
    
    M1 --> BM
    M2 --> BM
    M3 --> BM
    
    BM --> GC
    
    PA --> LSM
    PA --> KP
    PA --> MF
    PA --> PC
    PA --> WFP
    
    LSM --> ER
    KP --> ER
    MF --> ER
    PC --> ER
    WFP --> ER
```

### 2.2 分层设计

| 层级 | 功能职责 | 主要组件 |
|------|---------|---------|
| 平台适配层 | 屏蔽平台差异，提供统一接口 | LSM/Kprobe、MiniFilter/WFP |
| 事件处理层 | 事件过滤、路由、分发 | 过滤器、路由器、分发器 |
| 业务模块层 | 事件加工、策略判定 | 各业务模块 |
| 缓冲管理层 | 内存管理、数据存储 | 缓冲区管理器、GC |
| 通信层 | 内核用户态通信 | 共享内存、事件通知、控制接口 |

## 3. 核心功能模块设计

### 3.1 事件采集模块

#### 3.1.1 采集事件类型

```mermaid
graph LR
    subgraph "文件事件"
        FO["open"]
        FC["close"]
        FR["read"]
        FW["write"]
        FD["delete"]
        FRN["rename"]
    end
    
    subgraph "进程事件"
        PF["fork"]
        PE["exec"]
        PX["exit"]
        PS["setuid"]
        PK["kill"]
    end
    
    subgraph "网络事件"
        NC["connect"]
        NB["bind"]
        NL["listen"]
        NA["accept"]
        NS["send/recv"]
    end
```

#### 3.1.2 平台采集策略

**Linux平台**：
- 主数据源：LSM（Linux Security Module）
  - 覆盖90%以上安全相关事件
  - 原生支持阻断操作
  - API稳定，性能开销低
- 辅助数据源：Kprobe
  - 仅用于LSM未覆盖事件（如fork）
  - 动态插桩，灵活性高

**Windows平台**：
- MiniFilter：文件系统过滤
- 进程/线程创建回调
- WFP（Windows Filtering Platform）：网络过滤
- 注册表/对象回调

### 3.2 事件过滤模块

#### 3.2.1 过滤器架构

```mermaid
graph TD
    E["原始事件"] --> WL["白名单检查"]
    WL --> |"命中"| DROP["丢弃"]
    WL --> |"未命中"| RF["规则过滤"]
    RF --> BC["Bypass检查"]
    BC --> |"Bypass开启"| DROP
    BC --> |"正常"| SUB["订阅检查"]
    SUB --> |"无订阅"| DROP
    SUB --> |"有订阅"| PASS["通过"]
```

#### 3.2.2 过滤条件设计

| 过滤类型 | 支持条件 | 匹配方式 |
|---------|---------|---------|
| 进程过滤 | 进程名称、路径前缀 | 精确/前缀匹配 |
| 文件过滤 | 后缀、路径、操作进程 | 通配符匹配 |
| 网络过滤 | 端口、IP段、协议 | 范围/掩码匹配 |

### 3.3 事件分发模块

#### 3.3.1 分发流程

```mermaid
sequenceDiagram
    participant ES as "事件源"
    participant D as "分发器" 
    participant M1 as "业务模块1" 
    participant M2 as "业务模块2" 
    participant B as "缓冲区" 
    participant U as "用户态" 
    
    ES->>D: "过滤后事件"
    D->>M1: "顺序分发"
    M1->>M1: "事件加工"
    alt "需要上抛"
        M1->>B: "写入缓冲"
        B->>U: "通知"
        alt "同步上抛"
            U->>B: "返回决策"
            B->>M1: "决策结果"
        end
    end
    M1->>D: "返回结果"
    D->>M2: "继续分发"
    M2->>M2: "处理"
    M2->>D: "返回"
    D->>ES: "汇总结果"
```

#### 3.3.2 上抛机制设计

**注册机制**：
- 支持多进程订阅同一事件
- 区分同步/异步上抛需求
- 同步上抛需指定超时时间

**同步上抛**：
- 阻塞等待用户态决策
- 超时自动放行
- Linux: ioctl实现
- Windows: DeviceIoControl实现

**异步上抛**：
- 写入缓冲区后立即返回
- 通过EventFD/Event通知
- 支持批量处理

### 3.4 缓冲区管理模块

#### 3.4.1 缓冲区结构设计

```mermaid
graph TD
    subgraph "环形缓冲区"
        H["Header区"]
        D1["数据块1"]
        D2["数据块2"]
        D3["数据块3"]
        DN["数据块N"]
    end
    
    subgraph "事件结构"
        EH["事件头"]
        EB["事件体"]
        AB["ACK位图"]
    end
    
    D1 --> EH
    EH --> EB
    EB --> AB
```

#### 3.4.2 内存管理策略

```mermaid
graph LR
    subgraph "内存池"
        P1["池1: 512B"]
        P2["池2: 1KB"]
        P3["池3: 4KB"]
        P4["池4: 8KB"]
    end
    
    E1["小事件"] --> P1
    E2["中事件"] --> P2
    E3["大事件"] --> P3
    E4["巨事件"] --> P4
```

**关键特性**：
- 单份存储，多进程共享（零拷贝）
- 进度信息内嵌事件中
- 原子操作确认，无需系统调用
- 支持版本兼容
- 预留双缓冲设计

### 3.5 垃圾回收模块

#### 3.5.1 回收策略

```mermaid
stateDiagram-v2
    [*] --> Active: "事件写入"
    Active --> Marked: "所有进程已读"
    Active --> Marked: "超时"
    Marked --> Grace: "标记回收"
    Grace --> Reclaim: "RCU宽限期"
    Reclaim --> [*]: "空间回收"
    
    Active --> Force: "紧急回收"
    Force --> [*]: "强制释放"
```

#### 3.5.2 回收触发条件

| 触发条件 | 阈值 | 处理策略 |
|---------|------|---------|
| 软限制 | 70% | 加速回收 |
| 硬限制 | 90% | 强制回收 |
| 紧急限制 | 95% | 丢弃新事件 |

## 4. 平台抽象设计

### 4.1 抽象接口层

```c
// 平台无关接口定义
typedef struct {
    // 事件采集
    int (*init_hooks)(void);
    void (*cleanup_hooks)(void);
    
    // 内存管理
    void* (*alloc_memory)(size_t size);
    void (*free_memory)(void* ptr);
    
    // 同步机制
    void (*lock_acquire)(void* lock);
    void (*lock_release)(void* lock);
    
    // 通信接口
    int (*create_channel)(void);
    int (*send_event)(void* event);
} platform_ops_t;
```

### 4.2 条件编译最小化

```mermaid
graph LR
    subgraph "编译时"
        CC["CMake配置"]
        CC --> |"Linux"| LC["Linux配置"]
        CC --> |"Windows"| WC["Windows配置"]
    end
    
    subgraph "运行时"
        PI["平台接口"]
        PI --> FP["函数指针表"]
        FP --> |"动态选择"| IMP["具体实现"]
    end
```

## 5. 可靠性设计

### 5.1 异常处理机制

```mermaid
graph TD
    E["异常事件"] --> DT["检测类型"]
    DT --> |"慢读"| SR["慢读处理"]
    DT --> |"崩溃"| CR["崩溃处理"]
    DT --> |"缓冲满"| BF["缓冲满处理"]
    
    SR --> |"等待"| W["继续等待"]
    SR --> |"超时"| SK["跳过处理"]
    
    CR --> CL["清理资源"]
    CL --> RM["移除订阅"]
    
    BF --> |"小于 70%"| NM["正常"]
    BF --> |"70-90%"| AC["加速回收"]
    BF --> |"大于 90%"| FR["强制回收"]
```

### 5.2 并发安全设计

| 场景 | 保护机制 | 实现方式 |
|------|---------|---------|
| 多生产者 | Per-CPU缓冲 | 减少锁竞争 |
| 多消费者 | RCU | 读路径无锁 |
| 原子操作 | CAS | 无锁更新 |
| 内存屏障 | Barrier | 保证顺序性 |

### 5.3 心跳机制

```mermaid
sequenceDiagram
    participant K as "内核态"
    participant U as "用户态"
    participant M as "监控"
    
    loop 每30秒
        U->>K: "心跳请求"
        K->>U: "状态响应"
        U->>M: "上报状态"
    end
    
    alt "心跳超时"
        M->>M: "标记异常"
        M->>K: "查询状态"
        alt "无响应"
            M->>M: "触发告警"
        end
    end
```

## 6. 流程设计

### 6.1 系统初始化流程

```mermaid
graph TD
    START["开始"] --> CHK["检查内核版本"]
    CHK --> |"不支持"| ERR["返回错误"]
    CHK --> |"支持"| LOAD["加载驱动"]
    LOAD --> INIT["初始化内存池"]
    INIT --> REG["注册回调"]
    REG --> HOOK["安装Hook"]
    HOOK --> CHAN["创建通信通道"]
    CHAN --> READY["就绪状态"]
```

### 6.2 事件处理流程

```mermaid
graph TD
    EVENT["事件触发"] --> COLLECT["采集事件"]
    COLLECT --> FILTER["过滤检查"]
    FILTER --> |"丢弃"| END1["结束"]
    FILTER --> |"通过"| ROUTE["路由分发"]
    ROUTE --> PROCESS["业务处理"]
    PROCESS --> |"需上抛"| BUFFER["写缓冲区"]
    PROCESS --> |"不上抛"| END2["结束"]
    BUFFER --> NOTIFY["通知用户态"]
    NOTIFY --> |"同步"| WAIT["等待响应"]
    NOTIFY --> |"异步"| END3["结束"]
    WAIT --> |"超时"| DEFAULT["默认处理"]
    WAIT --> |"响应"| APPLY["应用决策"]
    DEFAULT --> END4["结束"]
    APPLY --> END5["结束"]
```

### 6.3 缓冲区读取流程

```mermaid
graph TD
    READ["读请求"] --> CHECK["检查权限"]
    CHECK --> |"无权限"| DENY["拒绝"]
    CHECK --> |"有权限"| MAP["映射内存"]
    MAP --> SCAN["扫描事件"]
    SCAN --> |"有新事件"| PROC["处理事件"]
    SCAN --> |"无新事件"| WAIT["等待通知"]
    PROC --> ACK["确认读取"]
    ACK --> UPDATE["更新位图"]
    UPDATE --> NEXT["下一事件"]
    WAIT --> |"超时"| TIMEOUT["返回超时"]
    WAIT --> |"通知"| SCAN
```

### 6.4 垃圾回收流程

```mermaid
graph TD
    TIMER["定时器触发"] --> SCAN["扫描缓冲区"]
    SCAN --> CHECK["检查ACK位图"]
    CHECK --> |"全部确认"| MARK["标记回收"]
    CHECK --> |"部分确认"| AGE["检查时间"]
    AGE --> |"超时"| FORCE["强制标记"]
    AGE --> |"未超时"| SKIP["跳过"]
    MARK --> RCU["RCU等待"]
    FORCE --> RCU
    RCU --> FREE["释放内存"]
    FREE --> UPDATE["更新指针"]
    SKIP --> NEXT["下一块"]
```

## 7. 部署与配置

### 7.1 Linux部署要求

```yaml
kernel:
  version: ">= 4.0"
  config:
    - CONFIG_SECURITY=y
    - CONFIG_SECURITY_SELINUX=y
    - CONFIG_KPROBES=y
    
loading:
  method: "module"  # module 或 built-in
  path: "/lib/modules/$(uname -r)/extra/"
  
permissions:
  - CAP_SYS_MODULE
  - CAP_SYS_ADMIN
```

### 7.2 Windows部署要求

```yaml
system:
  version: ">= Windows 7"
  arch: ["x64", "x86"]
  
driver:
  signing: "required"  # EV证书签名
  type: "kernel"
  framework: "WDF"
  
installation:
  method: "inf"
  service: "boot-start"
```

## 8. 接口定义

### 8.1 用户态API

```c
// 初始化接口
int kec_init(kec_config_t* config);

// 事件订阅
int kec_subscribe(event_type_t type, callback_t cb, int flags);

// 事件读取
int kec_read_events(event_t* buffer, size_t count, int timeout);

// 响应决策
int kec_respond(event_id_t id, decision_t decision);

// 配置更新
int kec_update_config(config_type_t type, void* config);

// 清理接口
void kec_cleanup(void);
```

### 8.2 内核态接口

```c
// 事件注册
int register_event_handler(event_type_t type, handler_t handler);

// 事件发送
int emit_event(event_t* event);

// 缓冲区操作
void* alloc_event_buffer(size_t size);
void free_event_buffer(void* buffer);

// 同步原语
void event_lock(lock_t* lock);
void event_unlock(lock_t* lock);
```

## 9. 数据结构定义

### 9.1 核心数据结构

```c
// 事件头结构
typedef struct {
    uint32_t magic;          // 魔数标识
    uint32_t version;        // 版本号
    uint64_t timestamp;      // 时间戳
    uint32_t event_type;     // 事件类型
    uint32_t event_size;     // 事件大小
    uint32_t process_id;     // 进程ID
    uint32_t thread_id;      // 线程ID
    uint64_t sequence;       // 序列号
    uint32_t ack_bitmap;     // 确认位图
    uint32_t reserved;       // 保留字段
} event_header_t;

// 文件事件结构
typedef struct {
    event_header_t header;
    uint32_t operation;      // 操作类型
    uint32_t flags;          // 操作标志
    uint64_t file_id;        // 文件ID
    char path[PATH_MAX];     // 文件路径
} file_event_t;

// 缓冲区管理结构
typedef struct {
    void* base_addr;         // 基地址
    size_t total_size;       // 总大小
    atomic_t write_pos;      // 写位置
    atomic_t read_pos;       // 读位置
    atomic_t ref_count;      // 引用计数
    spinlock_t lock;         // 自旋锁
} ring_buffer_t;
```

## 10. 测试方案

### 10.1 功能测试

| 测试项 | 测试内容 | 预期结果 |
|--------|---------|---------|
| 事件采集 | 各类事件触发 | 100%采集率 |
| 过滤功能 | 规则匹配 | 准确过滤 |
| 并发处理 | 多进程读写 | 数据一致 |
| 异常恢复 | 进程崩溃 | 自动恢复 |

### 10.2 性能测试

```mermaid
graph LR
    subgraph "测试场景"
        T1["单进程压测"]
        T2["多进程并发"]
        T3["极限吞吐"]
        T4["长时间稳定性"]
    end
    
    subgraph "测试指标"
        M1["延迟分布"]
        M2["吞吐量"]
        M3["CPU占用"]
        M4["内存占用"]
    end
    
    T1 --> M1
    T2 --> M2
    T3 --> M3
    T4 --> M4
```

## 11. 版本兼容性设计

### 11.1 版本管理策略

```mermaid
graph TD
    V1["V1.0基础版"] --> V2["V1.1功能增强"]
    V2 --> V3["V2.0重大升级"]
    
    subgraph "兼容性保证"
        API["API兼容"]
        ABI["ABI兼容"]
        PROTO["协议兼容"]
    end
    
    V1 -.-> API
    V2 -.-> API
    V2 -.-> ABI
    V3 -.-> PROTO
```

### 11.2 升级方案

- **向前兼容**：新版本支持旧版本数据格式
- **版本协商**：启动时协商使用的协议版本
- **平滑升级**：支持灰度升级策略
- **回滚机制**：保留回滚到前一版本能力

## 12. 安全考虑

### 12.1 安全威胁分析

| 威胁类型 | 风险等级 | 缓解措施 |
|---------|---------|---------|
| 权限提升 | 高 | 严格权限检查 |
| 拒绝服务 | 中 | 资源限制 |
| 信息泄露 | 中 | 数据加密 |
| 恶意注入 | 低 | 输入验证 |

### 12.2 安全加固措施

- **最小权限原则**：仅授予必要权限
- **输入验证**：严格验证所有输入
- **安全编码**：遵循安全编码规范
- **审计日志**：记录关键操作

## 13. 监控与运维

### 13.1 监控指标

```mermaid
graph LR
    subgraph "系统指标"
        CPU["CPU使用率"]
        MEM["内存占用"]
        IO["IO吞吐"]
    end
    
    subgraph "业务指标"
        EPS["事件/秒"]
        LAT["处理延迟"]
        ERR["错误率"]
    end
    
    subgraph "告警阈值"
        A1["CPU > 80%"]
        A2["延迟 > 100ms"]
        A3["错误率 > 1%"]
    end
```

### 13.2 运维工具

- **状态查询**：实时查看系统状态
- **配置管理**：动态更新配置
- **日志分析**：问题定位工具
- **性能分析**：性能瓶颈分析

## 14. 开发规范

### 14.1 代码组织

```
project/
├── include/          # 头文件
│   ├── common/      # 公共头文件
│   ├── linux/       # Linux专用
│   └── windows/     # Windows专用
├── src/             # 源代码
│   ├── core/        # 核心模块
│   ├── platform/    # 平台相关
│   └── utils/       # 工具函数
├── tests/           # 测试代码
├── docs/            # 文档
└── CMakeLists.txt   # 构建配置
```

### 14.2 编码规范

- **命名规范**：小写下划线分隔
- **注释要求**：关键逻辑必须注释
- **错误处理**：统一错误码定义
- **日志规范**：分级日志输出

## 15. 风险评估与应对

### 15.1 技术风险

| 风险项 | 概率 | 影响 | 应对措施 |
|--------|------|------|---------|
| 内核版本兼容 | 中 | 高 | 多版本适配 |
| 性能瓶颈 | 低 | 高 | 性能优化预案 |
| 内存泄漏 | 低 | 高 | 严格测试 |
| 驱动签名 | 低 | 中 | 提前申请证书 |

### 15.2 项目风险

- **进度风险**：分阶段交付，优先核心功能
- **资源风险**：预留缓冲时间
- **质量风险**：持续集成测试
- **维护风险**：完善文档体系

## 16. 总结

本设计文档详细描述了跨平台内核事件采集系统的完整架构和实现方案。系统采用分层架构设计，通过平台抽象层实现跨平台支持，通过共享内存和零拷贝技术实现高性能数据传输。设计充分考虑了可靠性、可扩展性和可维护性，为后续开发提供了清晰的指导。

### 关键设计亮点

1. **平台抽象设计**：70%代码跨平台复用
2. **零拷贝架构**：共享内存减少数据复制
3. **智能垃圾回收**：基于ACK位图的精确回收
4. **灵活的分发机制**：支持同步/异步多种模式
5. **完善的异常处理**：多级容错保证系统稳定

### 后续工作

1. 详细API文档编写
2. 性能基准测试
3. 安全审计
4. 持续优化迭代